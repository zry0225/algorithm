package com.zry;

/**
 * @author zry
 * @Date 2022/1/24
 * @ApiNote
 *  思路：将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间中只有一个元素，就是数组中第一个元素。
 *  插入算法的核心思想是未排序区间的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。
 *  重复这个过程，直到未排序区间中元素为空，算法结束。
 *  插入排序包括两种操作：元素比较、元素移动
 *  当我们需要将一个数据a插入到已排序区间时，需要拿a与排序区间的元素依次比较大小，找到合适的插入位置。
 *  找到插入点后，我们还需要将插入点之后的元素顺序往后移动一位，给a腾出位置。
 *
 *  插入排序并不需要额外的存储空间，所以空间复杂度为O(1),也就是说，这是一个原地排序算法。
 *  在插入排序中，如果碰到值相同的元素，我们可以选择将后面出现的元素插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定排序算法
 *  如果要排序的数据是有序的，我们并不需要移动任何数据。如果我们从尾到头在有序区间中查找插入位置，每次只需要比较一个数据就能找到需要插入的位置。所以时间复杂度为O(n)
 *  如果数据是倒序的，每次插入都相当于在已排序区间的第一个位置插入新的数据，所以需要移动很多数据，最坏的时间复杂度为O(n2).
 *  对于插入排序来说，每次插入操作都需要相当于在数组中插入一个数据，循环执行n次插入操作，所以平均时间复杂度为O(n2)
 */
public class InsertionSort {
    /**
     * 插入排序
     * @param a 数组
     * @param n 数组大小
     */
    public void insertionSort(int[] a,int n){
        if (n<=1){
            return;
        }
        for (int i = 1; i < n; ++i) {
            int value = a[i];
            int j = i-1;
            //查找插入的位置
            for (; j >= 0; --j) {
                if (a[j] > value){
                    //数据移动
                    a[j+1] = a[j];
                }else {
                    break;
                }
            }
            //插入数据
            a[j+1] = value;
        }
    }
}
